# The format version is an indicator of the compatibility of community exercises with the
# Rustlings program.
# The format version is not the same as the version of the Rustlings program.
# In case Rustlings makes an unavoidable breaking change to the expected format of community
# exercises, you would need to raise this version and adapt to the new format.
# Otherwise, the newest version of the Rustlings program won't be able to run these exercises.
format_version = 1

# Optional multi-line message to be shown to users when just starting with the exercises.
welcome_message = """
'                      __  ___
'     _______  _______/ /_/ (_)___  ____ ______
'    / ___/ / / / ___/ __/ / / __ \\/ __ `/ ___/
'   / /  / /_/ (__  ) /_/ / / / / / /_/ (__  )
'  /_/   \\__,_/____/\\__/_/_/_/ /_/\\__, /____/
'                                /____/
'
'     Bem-vindo a vers√£o brasileira
'"""

# Optional multi-line message to be shown to users after finishing all exercises.
final_message = """Espero que tenha se divertido e aprendido com esses exerc√≠cios :D"""


# Repeat this section for every exercise.
[[exercises]]
# Exercise name which is the exercise file name without the `.rs` extension.
name = "intro1"
dir = "00_intro"
test = false
hint = """Pressione `n` para ir para o pr√≥ximo exercic√≠o."""
skip_check_unsolved = true

[[exercises]]
name = "intro2"
dir = "00_intro"
test = false
hint = """Ser√° que `printline!` √© a forma correta ÔºüTalvez precisamos de outro comando."""

[[exercises]]
name = "variables1"
dir = "01_variables"
test = false
hint = """Precisamos dizer ao compilador que queremos uma nova vari√°vel"""

[[exercises]]
name = "variables2"
dir = "01_variables"
test = false
hint = """A mensagem do compilador indica que o Rust n√£o consegue deduzir o tipo da vari√°vel `x` a partir do c√≥digo.
O que acontece se adicionarmos uma anota√ß√£o de tipo na primeira linha da fun√ß√£o `main`?
E se atribuirmos um valor para `x`?
Se fizermos ambas as coisas, o que muda?
Al√©m disso, que tipo `x` deveria ter?
O que acontece se `x` e `10` forem do mesmo tipo? E se forem tipos diferentes?"""

[[exercises]]
name = "variables3"
dir = "01_variables"
test = false
hint = """Voc√™ est√° tentando usar uma vari√°vel que foi criada mas n√£o recebeu valor?
Esse erro √© comum em linguagens de programa√ß√£o (ainda bem que o compilador Rust detectou isso)."""

[[exercises]]
name = "variables4"
dir = "01_variables"
test = false
hint = """No Rust, as vari√°veis por padr√£o s√£o imut√°veis.
Mas aqui queremos atribuir um novo valor, ou seja, alterar essa vari√°vel.
Que palavra-chave precisamos adicionar ao declarar a vari√°vel para torn√°-la mut√°vel?"""

[[exercises]]
name = "variables5"
dir = "01_variables"
test = false
hint = """No exerc√≠cio `variables4`, aprendemos a usar uma palavra-chave especial para tornar vari√°veis mut√°veis.
Por√©m, neste exerc√≠cio, essa abordagem n√£o funciona.
Isso porque agora queremos atribuir um tipo diferente ao mesmo nome de vari√°vel. √Äs vezes, pode ser √∫til reutilizar o nome da vari√°vel (por exemplo, mudando apenas o tipo de dado).
Para isso, o Rust oferece o recurso de `shadowing` (sombreamento de vari√°veis).
Leia mais no The Rust Book:
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing"""

[[exercises]]
name = "variables6"
dir = "01_variables"
test = false
hint = """At√© agora aprendemos sobre vari√°veis e mutabilidade, mas existe um tipo importante no Rust chamado constante.
Constantes s√£o sempre imut√°veis e s√£o declaradas com a palavra-chave `const`.
Vale notar que o tipo da constante sempre precisa ser explicitamente declarado no c√≥digo.
Veja mais sobre diferen√ßas entre vari√°veis e constantes no The Rust Book:
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#constants"""

[[exercises]]
name = "functions1"
dir = "02_functions"
test = false
hint = """Dentro da fun√ß√£o `main` foi chamada a fun√ß√£o `call_me`, mas essa fun√ß√£o n√£o existe no c√≥digo.
Al√©m disso, parece que essa fun√ß√£o n√£o precisa de par√¢metros, nem retorna valor, parecido com a fun√ß√£o `main`."""

[[exercises]]
name = "functions2"
dir = "02_functions"
test = false
hint = """No Rust, a assinatura da fun√ß√£o (a parte que descreve entrada e sa√≠da) precisa declarar os tipos.
O que est√° faltando na fun√ß√£o `call_me`?"""

[[exercises]]
name = "functions3"
dir = "02_functions"
test = false
hint = """A declara√ß√£o da fun√ß√£o est√° correta, mas parece que o modo como ela est√° sendo chamada tem problema."""

[[exercises]]
name = "functions4"
dir = "02_functions"
test = false
hint = """A mensagem de erro aponta que falta declarar o tipo de retorno no final da fun√ß√£o `sale_price`, ap√≥s o ‚Äú->‚Äù. Veja como √© feito na fun√ß√£o `is_even`."""

[[exercises]]
name = "functions5"
dir = "02_functions"
test = false
hint = """Rust diferencia express√µes de instru√ß√µes.
Express√µes retornam um valor, instru√ß√µes apenas retornam `()` (vazio).
A fun√ß√£o `square` deveria retornar um `i32`, mas est√° retornando `()`.
Veja bem o c√≥digo da fun√ß√£o `square`."""

[[exercises]]
name = "if1"
dir = "03_if"
hint = """Voc√™ tamb√©m pode realizar a opera√ß√£o desejada em uma √∫nica linha.
No Rust, lembre-se destes pontos:
- Condi√ß√£o do `if` n√£o precisa de par√™nteses.
- `if` e `else` s√£o express√µes.
- Os blocos de c√≥digo geralmente v√™m entre `{}` ap√≥s a condi√ß√£o."""

[[exercises]]
name = "if2"
dir = "03_if"
hint = """Considere que em Rust cada bloco de condi√ß√£o precisa retornar valores do mesmo tipo.
Para saber o que o teste espera, leia o caso de teste: ‚Äúo que √© passado, o que se espera retornar‚Äù."""

[[exercises]]
name = "if3"
dir = "03_if"
hint = """Considere que em Rust cada bloco de condi√ß√£o precisa retornar valores do mesmo tipo."""

[[exercises]]
name = "quiz1"
dir = "quizzes"
hint = """Este exerc√≠cio ainda n√£o tem dica.
(Precisa de dica? Abra uma quest√£o em https://github.com/SandmeyerX/rustlings-zh-cn/issues)"""

[[exercises]]
name = "primitive_types1"
dir = "04_primitive_types"
test = false
hint = """Colocar o operador `!` antes de um valor booleano inverte o valor.
Exemplo: `!true == false`
Isso funciona tamb√©m com vari√°veis booleanas de valor `false`."""

[[exercises]]
name = "primitive_types2"
dir = "04_primitive_types"
test = false
hint = """No Rust, o tipo de caractere `char` tem estas caracter√≠sticas:
1. Definido por aspas simples: use aspas simples para um √∫nico caractere como `'A'` ou `'üòª'`, diferente das aspas duplas de string (`"abc"`).
2. Suporte Unicode: cada `char` tem 4 bytes e pode representar qualquer caractere Unicode, incluindo chin√™s, emojis etc.
3. Convers√£o de tipo: apenas `u8` pode ser convertido diretamente para `char` com `as`, outros tipos exigem m√©todos como `std::char::from_u32`.
4. Diferen√ßa para string: strings (`String`/`&str`) guardam sequ√™ncias de bytes em UTF-8, enquanto `char` guarda o c√≥digo Unicode diretamente."""

[[exercises]]
name = "primitive_types3"
dir = "04_primitive_types"
test = false
hint = """No Rust h√° uma maneira simples de inicializar arrays de tamanho fixo:
`let nums = [6; 99999];`
Isso cria um array de 99999 elementos, todos com valor 6.
O qu√™? Voc√™ disse que pode fazer assim: `let nums = [6, 6, 6, ..., 6, 6];`
Voc√™ √© persistente mesmo...
"""

[[exercises]]
name = "primitive_types4"
dir = "04_primitive_types"
hint = """Para passar no teste de `nice_slice`, use a sintaxe de fatia de array.
Extraia do array `a` os elementos do √≠ndice 1 at√© o 4 (exclusivo), assim: `&nome_array[inicio..fim]`."""

[[exercises]]
name = "primitive_types5"
dir = "04_primitive_types"
test = false
hint = """Use a sintaxe de desconstru√ß√£o de tupla: com o comando `let`, vincule os elementos da tupla `cat` √†s vari√°veis `name` e `age`, assim: `let (nome, idade) = nome_tupla;`."""

[[exercises]]
name = "primitive_types6"
dir = "04_primitive_types"
hint = """√çndices de tupla come√ßam em 0. Use `.√≠ndice` para acessar. Para atribuir o segundo elemento de `numbers` (√≠ndice 1) √† vari√°vel `second`, fa√ßa `let second = numbers.√≠ndice;`."""

[[exercises]]
name = "vecs1"
dir = "05_vecs"
hint = """No Rust existem duas formas de definir um vetor (array din√¢mico):
1. Use `Vec::new()` para criar um vetor vazio e depois adicionar elementos com `push`.
2. Use o macro `vec![]` para definir e inicializar elementos (mais simples se j√° sabe os valores).
Mais detalhes no The Rust Book:
https://doc.rust-lang.org/stable/book/ch08-01-vectors.html"""

[[exercises]]
name = "vecs2"
dir = "05_vecs"
hint = """No primeiro m√©todo, crie um vetor vazio e depois adicione elementos.
No segundo, mapeie os valores de entrada e colete (`collect`) em um vetor.
Tente implementar ambos e escolha o que preferir.
Dica: prefiro o segundo, acho mais ‚Äúrusty‚Äù e elegante ;)"""

[[exercises]]
name = "move_semantics1"
dir = "06_move_semantics"
hint = """Adicionar elementos ao `vec` altera seu valor, mas vari√°veis por padr√£o s√£o imut√°veis. Como declarar `vec` para permitir altera√ß√£o?"""

[[exercises]]
name = "move_semantics2"
dir = "06_move_semantics"
hint = """Ao rodar este exerc√≠cio, percebeu o erro ‚Äúempr√©stimo de valor j√° movido‚Äù?
No Rust, ao passar uma vari√°vel para uma fun√ß√£o sem retorno expl√≠cito, ela n√£o pode ser usada depois.
Ou seja, ao passar `vec0` para `fill_vec`, a posse (ownership) passa para `vec1`, e n√£o √© poss√≠vel acessar `vec0`.
Para resolver, crie um clone de `vec0` e passe o clone para `fill_vec`."""

[[exercises]]
name = "move_semantics3"
dir = "06_move_semantics"
hint = """Diferente do anterior, a linha `let mut vec = vec` no come√ßo da fun√ß√£o `fill_vec` foi removida.
Agora adicione o `mut` ao definir o vetor inicial."""

[[exercises]]
name = "move_semantics4"
dir = "06_move_semantics"
hint = """Reflita sobre o escopo do empr√©stimo mut√°vel. O que acontece ao modificar `x` com refer√™ncia mut√°vel?
Leia sobre refer√™ncias mut√°veis no The Rust Book:
https://doc.rust-lang.org/stable/book/ch04-02-references-and-borrowing.html"""

[[exercises]]
name = "move_semantics5"
dir = "06_move_semantics"
test = false
hint = """Veja o cap√≠tulo ‚ÄúRefer√™ncias e Empr√©stimos‚Äù do The Rust Book:
https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html
O primeiro problema √© que `get_char` obt√©m a posse da string, fazendo `data` ser movido, e assim n√£o pode ser usado em `string_uppercase`.
Corrija isso e ajuste tamb√©m a assinatura da fun√ß√£o `string_uppercase`."""

[[exercises]]
name = "structs1"
dir = "07_structs"
hint = """Rust tem tr√™s tipos de struct, cada um serve para agrupar dados relacionados.
Struct comum guarda dados e nomes (fields).
Struct tupla √© como uma tupla com nome, sem nomes nos campos.
Struct unit√°ria n√£o tem campos, √∫til com generics.
Neste exerc√≠cio, implemente todos os tipos de struct. Veja The Rust Book:
https://doc.rust-lang.org/stable/book/ch05-01-defining-structs.html"""

[[exercises]]
name = "structs2"
dir = "07_structs"
hint = """Criar inst√¢ncias de struct √© simples, basta informar os campos.
H√° tamb√©m formas abreviadas, veja no The Rust Book:
https://doc.rust-lang.org/stable/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax"""

[[exercises]]
name = "structs3"
dir = "07_structs"
hint = """Na fun√ß√£o `is_international`, talvez seja necess√°rio verificar destino, origem ou pa√≠ses envolvidos para saber se o pacote √© internacional.
Na fun√ß√£o `get_fees`, s√£o necess√°rios par√¢metros extras, e talvez campos sobre peso, dimens√µes, tipo de envio, destino etc. no struct `Package`.
Para saber mais sobre m√©todos, veja The Rust Book:
https://doc.rust-lang.org/stable/book/ch05-03-method-syntax.html"""

[[exercises]]
name = "enums1"
dir = "08_enums"
test = false
hint = """Crie todas as variantes usadas para o enum `Message`."""

[[exercises]]
name = "enums2"
dir = "08_enums"
test = false
hint = """No Rust voc√™ pode criar enums com diferentes formas de dados:
‚ÄãStruct an√¥nimo: `Move { x: i32, y: i32 }`
‚ÄãStruct nomeado: defina `struct Point` e vincule a variante `Move(Point)`
‚ÄãString √∫nica: `Echo(String)`
‚ÄãTupla: `ChangeColor(u8, u8, u8)`
‚ÄãSem dados: `Quit`
...
Isso permite que enums sejam flex√≠veis para v√°rios cen√°rios e tratados pelo padr√£o de correspond√™ncia."""

[[exercises]]
name = "enums3"
dir = "08_enums"
hint = """Primeiro, defina o tipo enum, sem erros.
Depois, na fun√ß√£o `process()`, crie uma express√£o `match`. Para acessar valores do enum, use a express√£o `match` para desconstruir."""

[[exercises]]
name = "strings1"
dir = "09_strings"
test = false
hint = """A fun√ß√£o `current_favorite_color` retorna um slice com tempo de vida `static`.
Como os dados da string est√£o embutidos no c√≥digo, eles existem durante toda a execu√ß√£o.
Apesar de slices de string e `String` serem diferentes, voc√™ pode converter usando `From`."""

[[exercises]]
name = "strings2"
dir = "09_strings"
test = false
hint = """Basta mudar o valor vinculado √† vari√°vel `word` de `String` para slice de string (`&str`).
Outra abordagem: na express√£o `if`, adicione um caractere para for√ßar a convers√£o de `String` para slice.
Para entender a convers√£o, veja The Rust Book:
https://doc.rust-lang.org/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods"""

[[exercises]]
name = "strings3"
dir = "09_strings"
hint = """A biblioteca padr√£o de strings traz fun√ß√µes √∫teis:
https://doc.rust-lang.org/std/string/struct.String.html#method.trim
`compose_me`: use o macro `format!` ou converta slices para `String`.
Para a fun√ß√£o expans√≠vel `replace_me`, veja o m√©todo `replace`:
https://doc.rust-lang.org/std/string/struct.String.html#method.replace"""

[[exercises]]
name = "strings4"
dir = "09_strings"
test = false
hint = """Substitua a chamada `placeholder` na fun√ß√£o `main` por `string` ou `string_slice`.
Por exemplo, `placeholder("blue");` deve virar `string_slice("blue");`
Isso porque `"blue"` √© do tipo `&str`."""

[[exercises]]
name = "modules1"
dir = "10_modules"
test = false
hint = """No Rust, por padr√£o quase tudo √© privado. Use a palavra-chave `pub` para tornar p√∫blico."""

[[exercises]]
name = "modules2"
dir = "10_modules"
test = false
hint = """Este exerc√≠cio ainda n√£o tem dica.
(Precisa de dica? Abra uma quest√£o em https://github.com/SandmeyerX/rustlings-zh-cn/issues)"""

[[exercises]]
name = "modules3"
dir = "10_modules"
test = false
hint = """Este exerc√≠cio ainda n√£o tem dica.
(Precisa de dica? Abra uma quest√£o em https://github.com/SandmeyerX/rustlings-zh-cn/issues)"""

[[exercises]]
name = "hashmaps1"
dir = "11_hashmaps"
hint = """Devem haver pelo menos 5 frutas e pelo menos 3 tipos diferentes de frutas."""

[[exercises]]
name = "hashmaps2"
dir = "11_hashmaps"
hint = """Use os m√©todos `entry` e `or_insert` da tabela hash.
Veja mais no The Rust Book:
https://doc.rust-lang.org/stable/book/ch08-03-hash-maps.html#adding-a-key-and-value-only-if-a-key-isnt-present"""

[[exercises]]
name = "hashmaps3"
dir = "11_hashmaps"
hint = """Dica 1:
Use os m√©todos `entry` e `or_insert` (ou `or_insert_with`) para inicializar o valor padr√£o de `TeamScores` quando o time n√£o existir.
Mais detalhes no The Rust Book:
https://doc.rust-lang.org/stable/book/ch08-03-hash-maps.html#adding-a-key-and-value-only-if-a-key-isnt-present

Dica 2:
Garanta que ao encontrar uma chave j√° existente, atualize o valor de acordo.
Mais detalhes no The Rust Book:
https://doc.rust-lang.org/stable/book/ch08-03-hash-maps.html#updating-a-value-based-on-the-old-value"""

[[exercises]]
name = "quiz2"
dir = "quizzes"
hint = """Este exerc√≠cio ainda n√£o tem dica.
(Precisa de dica? Abra uma quest√£o em https://github.com/SandmeyerX/rustlings-zh-cn/issues)"""

[[exercises]]
name = "options1"
dir = "12_options"
hint = """O tipo Option pode ter valor Some e seu valor interno, ou ser None.
Existem v√°rias formas de acessar o valor interno, como `unwrap` ou correspond√™ncia de padr√£o.
Usar `unwrap` √© f√°cil, mas pode causar p√¢nico (crash) se houver problema. Como evitar o crash?"""

[[exercises]]
name = "options2"
dir = "12_options"
hint = """Veja os exemplos:
- https://doc.rust-lang.org/rust-by-example/flow_control/if_let.html
- https://doc.rust-lang.org/rust-by-example/flow_control/while_let.html
Lembre-se, Option pode ser usado com `if let` ou `while let`.
Exemplo: ‚Äúif let Some(Some(x)) = y‚Äù, ou veja Option::flatten."""

[[exercises]]
name = "options3"
dir = "12_options"
test = false
hint = """O compilador avisa sobre transfer√™ncia parcial de posse. Veja o erro e corrija conforme orienta√ß√µes.
Depois, leia a documenta√ß√£o:
https://doc.rust-lang.org/std/keyword.ref.html"""

[[exercises]]
name = "errors1"
dir = "13_error_handling"
hint = """A fun√ß√£o `generate_nametag_text` n√£o deveria retornar Option, mas sim Result.
Fa√ßa isto:
- Altere a assinatura para `Result<String, String>`.
- Troque retornos `Some()` por `Ok()`.
- Troque retornos `None` por `Err(mensagem de erro)`."""

[[exercises]]
name = "errors2"
dir = "13_error_handling"
hint = """Voc√™ pode tratar usando `match` em `item_quantity`, ou usar o operador `?`.
Veja mais no The Rust Book:
https://doc.rust-lang.org/stable/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator"""

[[exercises]]
name = "errors3"
dir = "13_error_handling"
test = false
hint = """Se outras fun√ß√µes podem retornar Result, por que apenas main n√£o pode?
Na verdade, main pode retornar `Result<(), ErrorType>`, sendo `Ok(())` o resultado sem retorno.
"""

[[exercises]]
name = "errors4"
dir = "13_error_handling"
hint = """`PositiveNonzeroInteger::new` sempre cria uma nova inst√¢ncia e retorna valor.
Mas se a checagem falhar, retorna `Err`, caso contr√°rio, retorna `Ok`."""

[[exercises]]
name = "errors5"
dir = "13_error_handling"
test = false
hint = """No main s√£o gerados dois tipos diferentes de Result, ambos usando `?`.
Como permitir ambos como retorno?
O operador `?` chama `From::from` para converter o erro em `Box<dyn Error>`, aceitando v√°rios tipos de erro.
Veja boxing_errors no The Rust Book:
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/boxing_errors.html
E como usar o operador `?` com boxing_errors:
https://doc.rust-lang.org/rust-by-example/error/multiple_error_types/boxing_errors.html"""

[[exercises]]
name = "errors6"
dir = "13_error_handling"
hint = """Neste exerc√≠cio, usamos o `PositiveNonzeroInteger` do anterior.
Na linha abaixo do `TODO`, veja exemplo de uso do m√©todo `map_err` para converter tipos de erro.
Fa√ßa o mesmo com o Result do `parse`. O operador `?` pode ser usado para retorno antecipado.
Leia sobre `map_err` no The Rust Book:
https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"""

[[exercises]]
name = "generics1"
dir = "14_generics"
test = false
hint = """Vetores din√¢micos do Rust usam generics para aceitar qualquer tipo, com tamanho din√¢mico.
Se `numbers` for do tipo `Vec<T>`, s√≥ pode adicionar elementos do tipo T.
Antes de adicionar, pode usar `into` para converter valores para T. Mas o compilador n√£o sabe o tipo exato, ent√£o √© preciso anot√°-lo.
Tipos como `u8` e `i8` podem virar `i16`, `i32`, `i64` etc. Escolha o tipo gen√©rico!"""

[[exercises]]
name = "generics2"
dir = "14_generics"
hint = """Este exerc√≠cio ainda n√£o tem dica.
(Precisa de dica? Abra uma quest√£o em https://github.com/SandmeyerX/rustlings-zh-cn/issues)"""

[[exercises]]
name = "traits1"
dir = "15_traits"
hint = """Este exerc√≠cio ainda n√£o tem dica.
(Precisa de dica? Abra uma quest√£o em https://github.com/SandmeyerX/rustlings-zh-cn/issues)"""

[[exercises]]
name = "traits2"
dir = "15_traits"
hint = """A trait recebe a posse de `self` e retorna `Self`.
Na assinatura da trait, `append_bar` recebe `self` como par√¢metro, mas na implementa√ß√£o pode ser `mut self`.
Isso √© poss√≠vel pois o valor √© possu√≠do de qualquer forma."""

[[exercises]]
name = "traits3"
dir = "15_traits"
hint = """Este exerc√≠cio ainda n√£o tem dica.
(Precisa de dica? Abra uma quest√£o em https://github.com/SandmeyerX/rustlings-zh-cn/issues)"""

[[exercises]]
name = "traits4"
dir = "15_traits"
hint = """Voc√™ pode usar trait como par√¢metro no lugar de tipo espec√≠fico.
Tente substituir `???` por `impl [nome da trait]`.
Veja The Rust Book:
https://doc.rust-lang.org/stable/book/ch10-02-traits.html#traits-as-parameters"""

[[exercises]]
name = "traits5"
dir = "15_traits"
hint = """Para exigir que o par√¢metro implemente m√∫ltiplas traits, use a sintaxe `+`.
Substitua `???` por `impl [primeira trait] + [segunda trait]`.
Veja The Rust Book:
https://doc.rust-lang.org/stable/book/ch10-02-traits.html#specifying-multiple-trait-bounds-with-the--syntax"""

[[exercises]]
name = "quiz3"
dir = "quizzes"
hint = """Para este exerc√≠cio voc√™ precisa saber sobre traits, especialmente trait bounds.
Veja:
https://doc.rust-lang.org/stable/book/ch10-02-traits.html#using-trait-bounds-to-conditionally-implement-methods
Na implementa√ß√£o:
`impl<T: Trait1 + Trait2 + ‚Ä¶> for Foo<T> { ‚Ä¶ }`
Talvez precise de `use std::fmt::Display;`."""

[[exercises]]
name = "lifetimes1"
dir = "16_lifetimes"
hint = """Este exerc√≠cio ainda n√£o tem dica.
(Precisa de dica? Abra uma quest√£o em https://github.com/SandmeyerX/rustlings-zh-cn/issues)"""

[[exercises]]
name = "lifetimes2"
dir = "16_lifetimes"
test = false
hint = """Note que o lifetime `a` equivale ao menor lifetime entre `x` e `y`.
Para obter o resultado esperado mantendo o bloco interno, h√° duas op√ß√µes:
1. Mova a declara√ß√£o de `string2` para ter o mesmo lifetime de `string1` (como ficaria `result`?).
2. Mova o `println!` para dentro do bloco."""

[[exercises]]
name = "lifetimes3"
dir = "16_lifetimes"
test = false
hint = """Este exerc√≠cio ainda n√£o tem dica.
(Precisa de dica? Abra uma quest√£o em https://github.com/SandmeyerX/rustlings-zh-cn/issues)"""

[[exercises]]
name = "tests1"
dir = "17_tests"
hint = """`assert!` √© um macro que recebe um argumento. Se o valor for verdadeiro, n√£o faz nada (teste passa), se falso, gera p√¢nico (falha).
Teste com v√°rios valores, veja quais passam e quais falham.
Para testar `false`, pode usar `assert!(!...)`."""

[[exercises]]
name = "tests2"
dir = "17_tests"
hint = """`assert_eq!` √© um macro que compara dois argumentos.
Tente passar valores iguais. O que acontece se passar diferentes? E se inverter a ordem?"""

[[exercises]]
name = "tests3"
dir = "17_tests"
hint = """Neste teste, esperamos que `Rectangle::new` gere p√¢nico ao receber valores negativos.
Para isso, adicione um atributo especial ao teste.
Veja em Rust Book:
https://doc.rust-lang.org/stable/book/ch11-01-writing-tests.html#checking-for-panics-with-should_panic"""

[[exercises]]
name = "iterators1"
dir = "18_iterators"
hint = """Iteradores executam opera√ß√µes sobre todos elementos de uma cole√ß√£o. O que fazer quando terminam?
Veja:
https://doc.rust-lang.org/std/iter/trait.Iterator.html"""

[[exercises]]
name = "iterators2"
dir = "18_iterators"
hint = """`capitalize_first`: a vari√°vel `first` √© `char`. Para retornar `String` correta, converta para mai√∫sculo e adicione ao resto dos caracteres.
Veja m√©todos √∫teis em:
https://doc.rust-lang.org/std/primitive.char.html
Use `char::to_uppercase`, que retorna um iterador convert√≠vel para `String`.
`capitalize_words_vector`: crie um iterador a partir do slice e aplique `capitalize_first`, colete com `collect`.
`capitalize_words_string`: m√©todo similar.
O m√©todo `collect` √© poderoso. O Rust infere o tipo desejado."""

[[exercises]]
name = "iterators3"
dir = "18_iterators"
hint = """A fun√ß√£o `divide` deve retornar erro se o divisor for zero ou n√£o houver divis√£o exata.
A vari√°vel `division_results` deve ser uma cole√ß√£o dos resultados.
A fun√ß√£o `result_with_list` retorna um √∫nico `Result`, sucesso √© vetor de inteiros, erro √© `DivisionError`.
A fun√ß√£o `list_of_results` retorna vetor de resultados.
Leia sobre uso de `FromIterator` com `collect`:
https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect"""

[[exercises]]
name = "iterators4"
dir = "18_iterators"
hint = """Em linguagens imperativas, voc√™ faria um loop `for` ou recurs√£o com `match`.
No Rust, pode resolver o problema de fatorial de maneira funcional usando intervalo e iterador.
Veja m√©todos `fold` e `rfold`."""

[[exercises]]
name = "iterators5"
dir = "18_iterators"
hint = """O trait `std::iter::Iterator` tem v√°rios m√©todos √∫teis.
No `count_collection_iterator`, a vari√°vel `collection` √© um slice de `HashMap`, converta para iterador para usar m√©todos.
O m√©todo `fold` √© √∫til aqui.
Quer desafio extra? Procure outro m√©todo mais simples no Iterator!"""

[[exercises]]
name = "box1"
dir = "19_smart_pointers"
hint = """Este exerc√≠cio ainda n√£o tem dica.
(Precisa de dica? Abra uma quest√£o em https://github.com/SandmeyerX/rustlings-zh-cn/issues)"""

[[exercises]]
name = "rc1"
dir = "19_smart_pointers"
hint = """Este exerc√≠cio ainda n√£o tem dica.
(Precisa de dica? Abra uma quest√£o em https://github.com/SandmeyerX/rustlings-zh-cn/issues)"""

[[exercises]]
name = "arc1"
dir = "19_smart_pointers"
test = false
hint = """Este exerc√≠cio ainda n√£o tem dica.
(Precisa de dica? Abra uma quest√£o em https://github.com/SandmeyerX/rustlings-zh-cn/issues)"""

[[exercises]]
name = "cow1"
dir = "19_smart_pointers"
hint = """Este exerc√≠cio ainda n√£o tem dica.
(Precisa de dica? Abra uma quest√£o em https://github.com/SandmeyerX/rustlings-zh-cn/issues)"""

[[exercises]]
name = "threads1"
dir = "20_threads"
test = false
hint = """`JoinHandle` √© a estrutura retornada pela thread criada.
https://doc.rust-lang.org/std/thread/fn.spawn.html
Em programas multithread, o problema √© que a thread principal pode encerrar antes das threads criadas. Use `JoinHandle` para esperar cada thread e coletar o resultado."""

[[exercises]]
name = "threads2"
dir = "20_threads"
test = false
hint = """`Arc` √© um ponteiro com contagem de refer√™ncia at√¥mica, permitindo acesso seguro compartilhado a dados imut√°veis.
Mas neste exerc√≠cio queremos alterar `jobs_done`, ent√£o precisamos de outro tipo que permita apenas um thread alterar por vez.
Veja no The Rust Book:
https://doc.rust-lang.org/stable/book/ch16-03-shared-state.html#using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time"""

[[exercises]]
name = "threads3"
dir = "20_threads"
hint = """Outra abordagem para concorr√™ncia entre threads √© usar canais mpc (multi-produtor, consumidor √∫nico).
Com um emissor e receptor, pode enviar valores em uma thread e receber em outra.
Clone o receptor para criar v√°rios produtores.
Veja no The Rust Book:
https://doc.rust-lang.org/stable/book/ch16-02-message-passing.html"""

[[exercises]]
name = "macros1"
dir = "21_macros"
test = false
hint = """Ao chamar macros no Rust, √© necess√°rio adicionar um caractere especial, diferente da chamada de fun√ß√£o comum."""

[[exercises]]
name = "macros2"
dir = "21_macros"
test = false
hint = """Macros no Rust n√£o seguem totalmente as regras de fun√ß√µes comuns.
A posi√ß√£o da defini√ß√£o e o local de uso s√£o importantes."""

[[exercises]]
name = "macros3"
dir = "21_macros"
test = false
hint = """Para usar macros fora do m√≥dulo, √© preciso trat√°-lo especialmente e exportar para o diret√≥rio superior."""

[[exercises]]
name = "macros4"
dir = "21_macros"
test = false
hint = """Basta adicionar um caractere para compilar.
Macros s√£o escritas separando cada ramo do macro com um certo s√≠mbolo.
Aqui termina o exerc√≠cio sobre macros, mas h√° muito mais para aprender.
Leia mais em The Little Book of Rust Macros:
https://veykril.github.io/tlborm/"""

[[exercises]]
name = "clippy1"
dir = "22_clippy"
test = false
hint = """A biblioteca padr√£o do Rust traz constantes matem√°ticas de precis√£o longa e infinita:
https://doc.rust-lang.org/stable/std/f32/consts/index.html
√Äs vezes queremos usar aproxima√ß√µes de constantes matem√°ticas, mas o Clippy alerta para valores imprecisos.
Veja os avisos do Clippy e use as constantes corretas de `std::f32::consts`."""

[[exercises]]
name = "clippy2"
dir = "22_clippy"
test = false
hint = """Loops sobre Option podem ser escritos como if-let."""
skip_check_unsolved = true

[[exercises]]
name = "clippy3"
dir = "22_clippy"
test = false
hint = """Este exerc√≠cio ainda n√£o tem dica.
(Precisa de dica? Abra uma quest√£o em https://github.com/SandmeyerX/rustlings-zh-cn/issues)"""

[[exercises]]
name = "using_as"
dir = "23_conversions"
hint = """Use o operador `as` para converter um dos operandos na √∫ltima linha da fun√ß√£o `average` para o tipo desejado."""

[[exercises]]
name = "from_into"
dir = "23_conversions"
hint = """Siga os mesmos passos que acabou de implementar em `From`."""

[[exercises]]
name = "from_str"
dir = "23_conversions"
hint = """Ao implementar `FromStr`, especifique o objeto `Person` e retorne `Ok`, se a string n√£o estiver correta, retorne o erro com `Err`.
Outra dica:
Use o m√©todo `map_err` de `Result` e uma closure para tratar erro do `parse::<u8>`.
Outra dica:
Se quiser usar o operador `?`, veja:
https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/reenter_question_mark.html"""

[[exercises]]
name = "try_from_into"
dir = "23_conversions"
hint = """Na biblioteca padr√£o, existe algo para convers√£o de inteiros ao implementar TryFrom e verificar faixa de entrada?
Desafio: √© poss√≠vel implementar TryFrom de forma gen√©rica para muitos tipos inteiros?"""

[[exercises]]
name = "as_ref_mut"
dir = "23_conversions"
hint = """Vamos adicionar o trait `AsRef<str>` ou `AsMut<u32>` como v√≠nculo de fun√ß√£o."""
